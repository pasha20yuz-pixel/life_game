#include "world.h"

/**
 * Подсчитывает количество живых соседей вокруг клетки (y, x).
 * Правила:
 * 1. Соседями считаются 8 окружающих клеток.
 * 2. Клетка сама себе не сосед (dx=0, dy=0 пропускаем).
 * 3. Если сосед выходит за границу поля, считаем его мертвым.
 */
int count_neighbors(int world[HEIGHT][WIDTH], int y, int x) {
    int count = 0;

    // Проходим по всем соседям в квадрате 3x3 вокруг (y, x)
    for (int dy = -1; dy <= 1; dy++) {
        for (int dx = -1; dx <= 1; dx++) {
            
            // Пропускаем саму центральную клетку
            if (dx == 0 && dy == 0) {
                continue;
            }

            // Координаты соседа
            int ny = y + dy;
            int nx = x + dx;

            // Проверяем, находится ли сосед в пределах поля
            if (ny >= 0 && ny < HEIGHT && nx >= 0 && nx < WIDTH) {
                // Если сосед живой (значение = 1), увеличиваем счетчик
                count += world[ny][nx];
            }
            // Если сосед за границей - он мертвый, ничего не делаем
        }
    }
    return count;
}

/**
 * Создает следующее поколение мира по правилам Конвея:
 * 1. Живая клетка с 2 или 3 соседями выживает, иначе умирает.
 * 2. Мертвая клетка с ровно 3 соседями оживает.
 * 
 * Важно: Мы не можем менять исходный мир "на лету", 
 * потому что новые значения повлияют на подсчет для соседних клеток.
 * Поэтому создаем временную копию мира.
 */
void next_generation(int world[HEIGHT][WIDTH]) {
    // Создаем временный мир для нового поколения
    int new_world[HEIGHT][WIDTH];

    // Проходим по каждой клетке исходного мира
    for (int y = 0; y < HEIGHT; y++) {
        for (int x = 0; x < WIDTH; x++) {
            
            // Подсчитываем соседей для текущей клетки
            int neighbors = count_neighbors(world, y, x);
            
            // Применяем правила Конвея:
            if (world[y][x] == 1) {
                // Правило для живой клетки: выживает только если 2 или 3 соседа
                new_world[y][x] = (neighbors == 2 || neighbors == 3) ? 1 : 0;
            } else {
                // Правило для мертвой клетки: оживает только если 3 соседа
                new_world[y][x] = (neighbors == 3) ? 1 : 0;
            }
        }
    }

    // Копируем новый мир обратно в исходный
    for (int y = 0; y < HEIGHT; y++) {
        for (int x = 0; x < WIDTH; x++) {
            world[y][x] = new_world[y][x];
        }
    }
}